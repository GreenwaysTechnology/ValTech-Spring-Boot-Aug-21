					Spring Boot
..............................................................................................

What is Spring Boot?

Spring Boot is JVM framework to build distributed application.

What is Spring Framework?
 -Spring Framework makes it easy to create java Enterprise applications.

Early 2000, Java Started becoming more popular in distributed application dev.

Distributed Apps:
-Monolith Apps
-MicroService Apps

How Java  Works? Who Provides Java Standarization?

JCP - Java Community Process
 Who standarize the entire Java Technology.

Types of Java Tech
JSE 
  Standard Edition
-Java Programming language
-JVM 
What is spec
   Rules and regualations how things are working.

What is implementation
Product which implements specs.

JVM -  Hot Spot(oracle),OpenJdk

JEE -Enterprise Specification
..............................
JEE Platform spec : containers /app containers/tools

WebTechnology spec
 Java servlet
 JSP
 JSF
 Websocket
 JSTL
 EL
Enterprise Application spec
EJB
JPA -ORM
JMS
JTA
DI
Context and DI
Concurrency Util

Web Services

SOAP based  -JAX-WS
REST Based  -JAX-RS

Management and Security technologies
Java EE Security spec
Java Auth
Java authorzation
JAVA EE additional spec
JMX -Jmeter,Spring Actuator

JME
....
 Building Device apps -Mobile Apps
.............................................................................................
                            Complixty of JEE Spec and implementation
.............................................................................................

////////////////////////////////////////////////////////////////////////////

JEE enterprise application:
............................

Client Layer         Web Layer      Biz layer      Data Layer/Persistency

Browser             Servlet/JSP      EJB               Entity Beans

EJB :Enterprise Java Bean
  Java Object can support distributed biz operations
eg: incase of shopping cart
  I have a bean(java object) which has three apis addToCart,Checkout,Payment)

Api classifications:
1.Session Bean  - to represent biz logic---jdbc--dml
2.Enitity bean  -ORM - Object to Table mapping-First orm solution---Hibernate
3.Message Driven Bean - Message driven systems-RabbitMQ,Kaffka,JMS

Rod  was working in enterprise banking application with jee, he faced lot of complexity in designing ejb driven systems, so he decided to move ejb from JEE application, he wrote book called expert  J2EE ONE ON ONE design and development.



He proposed a model  that model later on came as The project in "Spring Season" - Spring Framework.

Client Layer         Web Layer      Biz layer                Data Layer/Persistency

Browser             Spring MVC        Spring Services              Spring-orm - Spring-data

Spring development objective is "POJO". (Plain Old Java Object)

When you build enterprise java apps, no plumbing(bolier plate code),Spring framework takes care that plumbing.

..............................................................................................
				Enterprise application challanges
..............................................................................................

Java is Object Oriented Programming language.

Apps built on java collection of objects.

Object Oriented Principles:
...........................

1.Abstraction
2.Encapsulation
3.Hierarchy
4.Typing
5.Modularity
----------------------
6.Concurrency
7.Persistency



1.Object Management :Hierarchy

Object Relationship

-HAS-A -  Composition
-IS-A - Inheritance.

Enterprise application challanges:

1.Object Management

IOC : Inversion of Control
 Inversion -Do opposit
 of Control -Management

In enterprise application object creation and linking objects are so complex that should be removed from the developer.

Someone should take care object creation and linking= 
  =>This process is called as IOC.
The IOC suggest the automation program,that program called as IOC Container.

The first IOC Container
1.PICO Container
2.Spring container : It was born as enterprise container.

Spring container takes care of object creations and object linking .
Which is other wise called as "Dependency Injection" .
 Dependency - HAS-A
    injection - linking objects


Spring Application:
   The application is written in java technology, executed on Spring Container which is runtime for spring applications.spring container runs on jvm

			  Spring Application
				 |
			   Spring Container
				 |
				JVM
...................

what is framework?
   One Stop Solution
 Collection of tools and technologies provided in one place to build end to end applications mostly.
  
What spring framework offers?

 Spring offers collection of many projects.


1.Core:

IoC container,
Events, 
Resources, 
i18n,
Validation,
Data Binding,
Type Conversion, 
SpEL,
AOP.

Core Project
1.XML driven
2.Java Config Driven
3.Boot Driven


2.Web
Web Servlet	
 Spring MVC, WebSocket, SockJS, STOMP messaging.

Web Reactive	
  Spring WebFlux, WebClient, WebSocket.


3.Data Access
  SQL, NOSQL
SQL:
Transactions, DAO support, JDBC, ORM, Marshalling XML.
NOSQL
Mongodb....


Integration	
  Remoting, JMS, JCA, JMX, Email, Tasks, Scheduling, Cache.

Languages	
     Kotlin, Groovy, Dynamic languages.

Microservices

Reactive

Cloud 

Event Driven

Serverless
.............................................................................................
				   Tools For Spring Application Development
.............................................................................................

1.JDK 8 - 11
   HotSpot or OpenJDk
2.Build Tools
   Maven,Gradle
3.Docker

Spring Versions and features

2004 - Spring Framework 1.0 released
– Champions dependency injection
– Encourages POJOs
– Uses XML files to describe application
  configuration
– Becomes popular quickly as an EJB
  alternative

• Spring 2.0 (2006):
 – XML simplification, async JMS, JPA, AspectJ support

• Spring 2.5 (2007, last release 2.5.6)
  – Requires Java 1.4+ and supports JUnit 4
  – Annotation DI, @MVC controllers, XML namespaces

• Spring 3.x (3.2.17 released July 2013)

   – Environment & Profiles, @Cacheable, @EnableXXX …
   – Requires Java 1.5+ and JUnit 4.7+
   – REST support, JavaConfig, SpEL, more annotations

• Spring 4.x (released Dec 2016)
    – Support for Java 8, @Conditional, Web-sockets

• Spring 5.x (2017)
  MicroService driven Dev features
   – Reactive programming focus
   - Functional Programming
   - Cloud Functionality
   - Container support
...............................................................................................

Spring Core Concepts:

1.Spring Bean.

What is Bean?
   
  Bean is terminallogy coined by SUN Micro System to name java object.

Object vs Bean?

 -Same but Bean has some special characteristics  which was proposed by SUN micro system via 
"Java Bean Spec"

It is java class, based Java Bean standards
 	-class should be public
 	-properties should be private
 	-set and get methods - Accessors and mutators
	-constructors

Why Bean Spec?
  - in order to standarize the java dev process- Coding Standards.

class Customer {
  public int id;
  private String name;
}

Spring  follows java bean spec in order to create object and links objects.

class CustomerService {

   private CustomerRespository rep;

   CustomerService(){

   }
   set /get

}
class CustomerRespository{


}

Spring Bean is Java Object follows Bean Specification and also managemented by Spring Container.

.............................................................................................
				   Spring Bean Creation(Object)
.............................................................................................

Who creates Spring Beans?

 -Spring Container

 Spring container is java object, which manages object(bean) life cycle like   create,use,destroy.

How spring beans are created?

-> you must have bean definitions outside application biz logic
-> sp container reads that bean definitions, initalizes the beans.

Architecture:

			POJO Classes(Bean)
				 |
    Spring-Application <====>SpringContainer
      config file		 |
		       Fullyconfigured System


Spring Bean Definitions(file) instructs Spring Container how to create objects(order of creations) and how to link (DI) objects
............................................................................................
			Spring Application Configuration Managment
............................................................................................

Spring Application can be configured in many ways

1.XML files  -  Old and Legacy.

2.Java Config + Annotations

2.1 Java Config -Manual - Write Configuration and logic

 Here Dev need to write Configuration and biz logic , which makes app dev slower.

Just Focus logic, automate configuration itself - AutoConfig

3.AutoConfig:
    Framework must take care of configuration based on various condtions like
 i want web and jpa , messaging.
                        "Birth of Spring Boot"

.............................................................................................
				Spring Project Setup 
			    

What are the required components to setup Spring Project.

1.IDE,mvn,java

2.Project layout


Spring Project requires

Infra Structure:
 1.Project libraries

 2.Project Configurations

Application Structure

1.Application code
2.assets - imgs,docs
3.App Configuration

mvn or gradel
.............................................................................................
				    Spring Project Creations
............................................................................................

Whether you build app using Boot or Old Spring Framework Two things you have to take care

1.Project Dependency -  Libraries- core,web,data,cloud,logger....
  You have to manage
  Spring have to manage - Boot via starters

2.Application Configuration
   -Bean defintions -  xml
   


Spring Project Using Spring Framework method:



Steps:

1.create Plain Maven Project

pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>spring-app</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.9</version>
        </dependency>
    </dependencies>
</project>

2.place beans.xml in the class path - resources/beans.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="hello" class="com.valtech.spring.beans.HelloWorld">
    </bean>
</beans>

package com.valtech.spring.app;

import com.valtech.spring.beans.HelloWorld;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class HelloApp {
    public static void main(String[] args) {
        //Object Creation : Without Spring
        HelloWorld helloWorld = new HelloWorld();
        helloWorld.setMessage("Hello Spring");
        System.out.println(helloWorld.getMessage());
        //Object creation : Using Spring
        //Create Spring Container
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        //access bean
        HelloWorld bean = context.getBean(HelloWorld.class);
        //set message
        bean.setMessage("Hello Spring Bean");
        //get message
        System.out.println(bean.getMessage());


    }
}
.............................................................................................
				 Dependency Injection
............................................................................................

What is dependency Injection?

  Linking objects
  Setting Object Property values

  Setting Object references with Object who refers it.

Dependency Injection on reference types and Primitives

eg:
  OrderService needs OrderRepository


Types of DI:

1.Setter
    Linking objects after objects created
2.Constructor
    Linking objects, During object creation.

When to use Setter vs Constructor?

Note: 
 Constructor properties are initlized during object creations
 Settter properties are initlized after object creations

Spring supports both.You can mix and match.

Constructors:
  ->Enforce mandatory dependencies

Setters:
 1.Allow optional dependenices

Eg:
package com.valtech.spring.beans.di;

public class Customer {
    private int customerId;
    private String name;
    private Address address;

    public Customer() {
    }

    public Customer(int customerId, String name) {
        this.customerId = customerId;
        this.name = name;
    }

    public Customer(Address address) {
        this.address = address;
    }

    public Customer(int customerId, String name, Address address) {
        this.customerId = customerId;
        this.name = name;
        this.address = address;
    }

    @Override
    public String toString() {
        return "Customer{" +
                "customerId=" + customerId +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }

    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}

package com.valtech.spring.beans.di;

public class Address {
    private String city;

    @Override
    public String toString() {
        return "Address{" +
                "city='" + city + '\'' +
                '}';
    }

    public Address() {
    }

    public Address(String city) {
        this.city = city;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

package com.valtech.spring.beans.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class CustomerDIApp {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        //access bean
        Customer customer = context.getBean("customer",Customer.class);
//        customer.setCustomerId(1);
//        customer.setName("subramanian");
//        customer.getAddress().setCity("Coimbatore");
        System.out.println(customer);

        Customer customer1 = context.getBean("newCustomer",Customer.class);
        System.out.println(customer1);


    }

}
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="hello" class="com.valtech.spring.beans.HelloWorld">
    </bean>
    <bean id="customer" class="com.valtech.spring.beans.di.Customer">
        <property name="customerId" value="1"/>
        <property name="name" value="Subramanian"/>
        <!--Setter Injection-->
        <property name="address" ref="address"/>
    </bean>
    <bean id="newCustomer" class="com.valtech.spring.beans.di.Customer">
        <property name="customerId" value="1"/>
        <property name="name" value="default Name"/>
        <!--Constructor injection !-->
        <constructor-arg ref="address"></constructor-arg>
    </bean>
    <bean id="address" class="com.valtech.spring.beans.di.Address">
        <property name="city" value="coimbatore"/>
    </bean>
</beans>
............................................................................................
			 Program to Super Type - Interface Driven DI
............................................................................................


beans.xml
    <bean id="inmemory" class="com.valtech.spring.beans.di.interfaces.CustomerInMemoryRepositoryImpl"></bean>
    <bean id="jpaimpl" class="com.valtech.spring.beans.di.interfaces.CustomerJPARepositoryImpl"></bean>
    <bean id="customerservice" class="com.valtech.spring.beans.di.interfaces.CustomerService">
        <constructor-arg ref="inmemory"/>
    </bean>


package com.valtech.spring.beans.di.interfaces;

public interface CustomerRepository {
    String findAll();
}
package com.valtech.spring.beans.di.interfaces;

public class CustomerInMemoryRepositoryImpl implements  CustomerRepository{
    @Override
    public String findAll() {
        return "CustomerInMemoryRepositoryImpl";
    }
}
package com.valtech.spring.beans.di.interfaces;

public class CustomerJPARepositoryImpl implements CustomerRepository {
    @Override
    public String findAll() {
        return "CustomerJPARepositoryImpl";
    }
}
package com.valtech.spring.beans.di.interfaces;

public class CustomerService {
    //di with interface
    private CustomerRepository repository;

    public CustomerService(CustomerRepository repository) {
        this.repository = repository;
    }

    public CustomerService() {
    }

    public CustomerRepository getRepository() {
        return repository;
    }

    public void setRepository(CustomerRepository repository) {
        this.repository = repository;
    }

    public String findAll() {
        return repository.findAll();
    }
}

package com.valtech.spring.beans.di.interfaces;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class CustomerInterfaceApp {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        CustomerService customerService = context.getBean("customerservice", CustomerService.class);
        System.out.println(customerService.findAll());
    }
}
.............................................................................................
DI Values:
 You can inject primtives / scaller such as int,sting,char,boolean
 You can inject Objects(reference types) - Customer,Order,Address,Repository
 You can inject Collection types - such as List,Map,Set...

Proerty can have child elements:List
<property name="shippingAddress">
	<list>
		<ref bean="address" />
		<ref bean="address" />
		<ref bean="address" />
		<ref bean="address" />
		<ref bean="address" />
		<ref bean="address" />
	</list>
</property>
or via constructor
	<constructor-arg name="orders">
			<list>
				<ref bean="orderA" />
				<ref bean="orderB" />
				<ref bean="orderC" />
			</list>
		</constructor-arg>

<list> -ArrayList
............................................................................................
How to add List as dependency?

beans.xml
 <bean id="customer" class="com.valtech.spring.beans.di.Customer">
        <property name="customerId" value="1"/>
        <property name="name" value="Subramanian"/>
        <!--Setter Injection-->
        <property name="address" ref="address"/>

        <constructor-arg>
              <list>
                  <ref bean="orderA" />
                  <ref bean="orderB" />
                  <ref bean="orderC" />
              </list>
        </constructor-arg>
    </bean>

package com.valtech.spring.beans.di;

import java.util.List;


package com.valtech.spring.beans.di;

public class Order {
    private int orderId;
    private float orderValue;

    public Order() {
    }

    public Order(int orderId, float orderValue) {
        super();
        this.orderId = orderId;
        this.orderValue = orderValue;
    }


    public int getOrderId() {
        return orderId;
    }

    public void setOrderId(int orderId) {
        this.orderId = orderId;
    }

    public float getOrderValue() {
        return orderValue;
    }

    public void setOrderValue(float orderValue) {
        this.orderValue = orderValue;
    }

    @Override
    public String toString() {
        return "Order{" +
                "orderId=" + orderId +
                ", orderValue=" + orderValue +
                '}';
    }
}


public class Customer {
    private int customerId;
    private String name;
    private Address address;
    private List<Order> orders;


    public Customer(List<Order> orders) {
        this.orders = orders;
    }

    public List<Order> getOrders() {
        return orders;
    }

    public void setOrders(List<Order> orders) {
        this.orders = orders;
    }

    public Customer() {
    }

    public Customer(int customerId, String name) {
        this.customerId = customerId;
        this.name = name;
    }

    public Customer(Address address) {
        this.address = address;
    }

    public Customer(int customerId, String name, Address address) {
        this.customerId = customerId;
        this.name = name;
        this.address = address;
    }

    @Override
    public String toString() {
        return "Customer{" +
                "customerId=" + customerId +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }

    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
package com.valtech.spring.beans.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class CustomerDIApp {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        System.out.println(customer.getOrders());


    }

}
.......................................................................................

Bean Definitions:
1.How to create bean 
   class,factory-method

2.How to name beans?
   id,name,alias

3.scope of the beans? : visibility of the bean
   singleton,prototype,
   request,session,application,websocket

4.Dependence Injections
   constructor
   setter
   autowire

5.Lazy initialization mode
 controlling bean creations
  eagar-default
  lazy-ondemand
  lazy-init="true"

5.How to simplify bean injections? 
   Autowiring mode 
 no,byName,byType,constructor   
.............................................................................................
					Bean Creation
............................................................................................

1.Via class  
   Spring creates using new Operator
  new Order()

2.Via Factory Pattern

-if constructor marked private
   via factory factory api


beans.xml
    <bean id="authService" class="com.valtech.spring.beans.creation.AuthService" factory-method="getInstance" />


package com.valtech.spring.beans.creation;

public class AuthService {
    private String userName = "admin";
    private String password = "admin";

    private AuthService() {
    }

    // Factory Api
    public static AuthService getInstance() {
        return new AuthService();
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    // Biz Api
    public boolean login(String userName, String password) {
        if (this.getUserName().equals(userName) && this.getPassword().equals(password)) {

            return true;
        }
        return false;
    }
}


package com.valtech.spring.beans.creation;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class FactoryMainApp {
    public static void main(String[] args) {
        ApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");
        AuthService auth=factory.getBean("authService",AuthService.class);
        auth.setUserName("admin");
        auth.setPassword("admin");
        boolean isAuth = auth.login("admin", "admin");
        System.out.println(isAuth ? "Valid" : "Not Valid");
    }
}
.............................................................................................
					Bean Scopes
.............................................................................................
Generally, you can create multiple instance from bean definition.
  some times if you want to control that bean creation
you can use bean creation scope.

Spring supports 6 scopes:

1.singleton
 (Default) Scopes a single bean definition to a single object instance for each Spring IoC container.
 if you call getBean no of time, spring returns the only one instance at any point of time.
This is default scope.

package com.valtech.spring.beans.scopes;

public class ClientService {
    public void findAll() {
        System.out.println("Client Service-findAll");
    }
}


    <bean id="clientService" class="com.valtech.spring.beans.scopes.ClientService" scope="singleton" >
    </bean>


package com.valtech.spring.beans.scopes;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ScopeMain {
    public static void main(String[] args) {
        ApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");
        ClientService clientService = null;
        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());

        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());

        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());

    }
}

2.prototype:
a new bean instance every time a request for that specific bean is made 
that is, the bean is injected into another bean or you request it through a getBean() method call on the container.

    <bean id="clientService" class="com.valtech.spring.beans.scopes.ClientService" scope="prototype" >
    </bean>

package com.valtech.spring.beans.scopes;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ScopeMain {
    public static void main(String[] args) {
        ApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");
        ClientService clientService = null;
        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());

        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());

        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());

    }
}
Web Scope:
3.request 
 <bean id="flight" class="com.ae.trip.entity.Fight" scope="request"/>
	HttpServletRequest req;
	req.setAttribute("flight",flight)
	
	->Servlet--->Servlet---Servlet---NServlet---jsp
	->Servlet----jsp---Servlet--->Servlet--Jps....
4.session
	Single User multiple request,storing data about single User
	HttpSession session;
	session.setAttribute("flight",flight)
      <bean id="flight" class="com.ae.trip.entity.Fight" scope="session"/>
	User---ShoppingCart
	User---CheckoutScreen
	User---PaymentScren
5.application
	Global Data, eg Offers for all users in the web site
	ServletContext ctx;
	ctx.setAttribute("flight",flight)
	<bean id="offer" class="com.ae.trip.entity.Offer" scope="application"/>
6.websocket

 ->The request, session, application, and websocket scopes are available only if you use a web-aware Spring ApplicationContext implementation (such as XmlWebApplicationContext)
............................................................................................
				DI automations
............................................................................................
autowire:

////////////////////////////////////////////////////////////////////////////
Dependency Injections:
 ->property - setter injections
 ->constructor-arg ref ->constructor injections
 
->autowire 
Which is not new injection type, but it simplifies property and constructor injections

     no ->Explicit via property or constructor-arg
     byName - Implicit via property
     byType - Implicit via type + property
     constructor - Implicit via constructor

Lab:

Customer
    |
    Account
    Address ---->via autowire


eg:
 <bean id="cust" autowire="byType" class="com.valtech.spring.beans.di.autowire.Customer">
        <property name="id" value="1"/>
        <property name="name" value="default"/>
    </bean>
    <bean id="address" class="com.valtech.spring.beans.di.autowire.Address">
        <property name="city" value="coimbatore"/>
    </bean>

package com.valtech.spring.beans.di.autowire;

public class Customer {
    private int id;
    private String name;
    //address is variable which has to match against byName
    private Address address1;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress1() {
        return address1;
    }

    public void setAddress1(Address address1) {
        this.address1 = address1;
    }
    //    public Customer() {
//    }
//
//    public Customer(Address address) {
//        this.address = address;
//    }
//
//    public Customer(int id, String name, Address address) {
//        this.id = id;
//        this.name = name;
//        this.address = address;
//    }
//
//    public int getId() {
//        return id;
//    }
//
//    public void setId(int id) {
//        this.id = id;
//    }
//
//    public String getName() {
//        return name;
//    }
//
//    public void setName(String name) {
//        this.name = name;
//    }
//
////    public Address getAddress() {
////        return address;
////    }
////
////    public void setAddress(Address address) {
////        this.address = address;
////    }
}
package com.valtech.spring.beans.di.autowire;

public class Address {
    private String city;


    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}
package com.valtech.spring.beans.di.autowire;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AutoWireMain {
    public static void main(String[] args) {
        ApplicationContext factory = new ClassPathXmlApplicationContext("beans1.xml");
        Customer customer=factory.getBean("cust",Customer.class);
        System.out.println(customer.getAddress1().getCity());

    }
}

/////////////////////////////////////////////////////////////////////////////////////////

Bean life cycles:
.................
init
destroy

Points:
1.if you want to initalize the resources,
 Resources:
   Resource is nothing but ,something outside jvm
    ex: FileSystem,Databases,Network sockets,Graphics context....
  Resources must be mananaged properly , if not , it will give you
 memory leaks.

In general , resources are initialized inside Class constructors
eg:Establishing database,socket connections, create file points,open file

According to spring best practices, dont do it inside constructor
 Why
   WHich hindrences the bean intialization, which will drop app startup performance.

then where can i initlaize
 spring provides life cycle hooks
   ->init-method="initmethod"
   ->destroy-method="destroymethod" - Resouce clean up


    <bean id="custService" init-method="init" destroy-method="destroy" class="com.valtech.spring.beans.lifecycle.CustomerService"/>


package com.valtech.spring.beans.lifecycle;

public class CustomerService {
    public void init(){
        System.out.println("init");
    }
    public void destroy(){
        System.out.println("destory");
    }
}
package com.valtech.spring.beans.lifecycle;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class LifeMain {
    public static void main(String[] args) {
        ApplicationContext factory = new ClassPathXmlApplicationContext("beans1.xml");
        factory.getBean("custService",CustomerService.class);

    }

}
.............................................................................................
How to call destroy hook method on bean?

BeanFactory
 |
org.springframework.context.ApplicationContext
 |
->org.springframework.context.ConfigurableApplicationContext
   |
  registerShutdownHook();------->destroy method

beans.xml
    <bean id="custService" init-method="init" destroy-method="destroy" class="com.valtech.spring.beans.lifecycle.CustomerService"/>
.............................................................................................
				 Container Extensions Points
............................................................................................

Typically, an application developer does not need to subclass  ApplicationContext implementation classes.
 Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. 

Typically, an application developer does not need to subclass  ApplicationContext implementation classes.
 Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. 

Spring core System:

		  Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|
		| Spring IOC Container  |
		------------------------
			|
		       JVM

 How to add extensions(plugins) on to the Existing Spring Container?


 		 Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|--->Extensions
					|    1.BeanPostProcessor 
		|			|
		|			|
		| 			|
		| Spring IOC Container  |
		|			|
		|			|	
		|			|
		|		        |
		------------------------
			|
		       JVM

Feature
1.How to instrument beans
2.How to instrument containers


BeanPostProcessor: Extensions
..................
  BeanPostProcessor are classes that tells Spring what should be done after beans are created.


How to implement extension?

Steps:
1.Declare class
public class BeanPostProcessorExtension {

}
2.implement BeanPostProcessor interface
package com.ae.spring.extensions;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class BeanPostProcessorExtension implements BeanPostProcessor {

	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("postProcessAfterInitialization : " + bean + " " + beanName);
		return bean;
	}

	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("postProcessBeforeInitialization : " + bean + " " + beanName);
		return bean;
	}

}

beans.xml
<bean class="com.ae.spring.extensions.BeanPostProcessorExtension"/>
2.BeanFactoryPostProcessor : Container Extension, where we instrument container itself.

package com.ae.spring.extensions;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;

public class FactoryBeanPostProcessorExtension implements BeanFactoryPostProcessor {

	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

		System.out.println("Container Extensions : " + beanFactory);

	}

}

beans.xml
  <bean class="com.ae.spring.extensions.FactoryBeanPostProcessorExtension"/>

..............................................................................................
				More Container Features(extensions)

             Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|--->Extensions
					|    1.BeanPostProcessor 
		|			|    2.Features2
		|			|    3.Feature3
		| 			|    4.FeatureN
		| Spring IOC Container  |
		|			|
		|			|	
		|			|
		|		        |
		------------------------
			|
		       JVM
..............................................................................................
			Spring provides lot of built in Extensions
.............................................................................................


PropertyPlaceholderConfigurer :
   It is used to externalize the bean property values
eg:

Bean defintion file
<bean id="customer" class="com.ae.spring.entity.Customer"
  <property name="customerId" value="100">
</bean>

With PropertyPlaceHolder = ${propertykey} => propValue
eg: 
<bean id="customer" class="com.ae.spring.entity.Customer"
  <property name="customerId" value="${customer.id}">
</bean>

PropertyPlaceholderConfigurer 

classpath:customer-info.properties
customer.id=1
customer.name=Ram

eg:
Steps:
1.property file
src/main/java/customer-info.properties
customer.id=1
customer.name=Ram
2.Activate Extension to read Property file
  ->
<beanclass="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="locations" value="classpath:customer-info.properties" />
</bean>

3.Read Property value:
		ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
		Customer customer = context.getBean("customer", Customer.class);
		System.out.println(customer.getId() + " " + customer.getName());


.............................................................................................
				How to introduce Annotations
...............................................................................................

Annotations:
 Meta Information about class,methods,fields.

Why Annotation?
Annotations help to inject "boiler plate code" -The code which is not neccessary for the dev but necessary for compiler,build tools,document generation tools,runtime.

Spring Introduced Annoations to simplify the lot of code generations.

Types of Spring Annotations

1.Spring Properity annotations
2.JSR 250 Annotations 


How to introduce Annotations inside Spring?
 
 Via ContainerExtension Mechanism


Common Annotations:
1.RequiredAnnotationBeanPostProcessor - @Required
2.AutowiredAnnotationBeanPostProcessor  -@Autowrited
3.CommonAnnotationBeanPostProcessor  -@Common
4.PersistenceAnnotationBeanPostProcessor -@Entity
etc....

Steps to integrate Annotations:

1.Activate The Annoation via ContainerExtension Point Beans

beans.xml

 <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/>
 -@Required

 <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/>

 -@Autowried
<bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>


What if any one of the AnnotationBeanPostProcessor has its own dependency, we need to inject
That as well, other wise it will throw error.

what if i want to use more annotations, i need to add more AnnotationBeanPostProcessor beans in bean.xml
  This is very complex
............................................................................................
				Automation - Annoation Scanner
.............................................................................................

Spring added feature called automated scanner, which scans all annoations from the build path/class path, creates all the beans related to annotationBeanPostoer

How to tell spring container to scan annotations?

via beans.xml file

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

	<context:annotation-config />
	
</beans>
...........

Annoation Example

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>
    <bean id="cust" class=" com.valtech.spring.app.annotations.config.Customer"/>
    <bean id="address" class=" com.valtech.spring.app.annotations.config.Address"/>

</beans>

package com.valtech.spring.app.annotations.config;

import org.springframework.beans.factory.annotation.Autowired;

public class Customer {
    private  int id;
    private String name;
    @Autowired
    private Address address;



    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
package com.valtech.spring.app.annotations.config;

public class Address {
    private  String city;

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return "Address{" +
                "city='" + city + '\'' +
                '}';
    }
}
..............................................................................................
					Types of Annotations
..............................................................................................

1.JSR 250 annoations

@PostConstruct
@PreDestroy


2.Spring Annoations

How to remove bean definitions from the beans.xml file

<bean id="customer" class="com.valtech.beans.Customer" />

Stereotype Annotations:

Stereotype: "Same type of things but it adds extra behaviour based on context"


@Component

What is Component?

The term coined by Microsoft in 1989.
In Object Oriented System Every thing is Object
The Term object is more general term.

Component is also Object(Bean) in spring context
  ->It is resulable
  ->follows all java bean standards

In java technology:
Bean
 In java Bean is called "java Object Only"

EJB
 It is also java object, which is distributed

Enitity
 It is also java object, which is persitable into fs,networks,rdbms



What is use of @Component?
 ->To eleminate bean definition from beans.xml file

<bean id="customerService"  class="com.ae.spring.service.impl.CustomerServiceImpl"/>


Spring provides  stereotype annotations:
 @Component is core type

Api doc:

 @Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Indexed
public @interface Component

@Component is class level annotation,declared on the top of class.

Indicates that an annotated class is a "component"
Such classes are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning.

Auto-detection and component scanning:

base package: com.ae.spring
			    com
			     |
			    ae
			     |
                           spring
		    -----------------------------
		   |                            |
                service                        repo
		   |                            |
		 impl                          impl
-------------------------------       -----------------------------
  |               |                   |                          |
CustomerService ProductService     CustomerRepoImpl          ProductRepoImpl
Impl            Impl

@Component      @Component         @Component                @Component
.............................................................................................
				Automation - Stereotype Annoation Scanner
   ..............................................................................................
   
How to scan SteroTypes?

 <context:component-scan base-package="com.valtech.spring.beans.automation"/>

This package and its subpackages , scan and creates beans and make it ready.

@Component is a generic stereotype for any Spring-managed component.

@Repository, @Service, and @Controller are specializations of @Component for more specific use cases.

by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects.

.............................................................................................
				DOMAIN Driven Design
.............................................................................................

 
@Service:

@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Service

Indicates that an annotated class is a "Service", originally defined by Domain-Driven Design (Evans, 2003) as "an operation offered as an interface that stands alone in the model, with no encapsulated state."


@Repository:
@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Repository

indicates that an annotated class is a "Repository", originally defined by Domain-Driven Design (Evans, 2003) as "a mechanism for encapsulating storage, retrieval, and search behavior which emulates a collection of objects".

...........................................................................................

@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Controller
Indicates that an annotated class is a "Controller" (e.g. a web controller).
.............................................................................................
				 End of Xml Configuration
.............................................................................................

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--scanner for common Annotation -->
    <context:annotation-config/>
    <!--    Scanner for StreoType Annotations-->
    <context:component-scan base-package="com.valtech.spring.beans.automation"/>
</beans>
..............................................................................................
		What if i want to remove this beans.xml itself
			    Java Config
.............................................................................................

Thanks to XML ,Good bye to XML,Welcome to Java Config:
......................................................

What is Java Config?

JavaConfig <=======> beans.xml
  but it is pure java Program.



package com.valtech.spring.javaconfig;

import org.springframework.stereotype.Service;

@Service
public class CustomerService {
    public String findAll() {
        return "Hello";
    }
}

package com.valtech.spring.javaconfig;

//beans.xml === This java class

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    //bean creation
    @Bean
    public CustomerService getCustomerService() {
        return new CustomerService();
    }
}
package com.valtech.spring.javaconfig;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MainApp {
    public static void main(String[] args) {
        ApplicationContext ctx=new AnnotationConfigApplicationContext(AppConfig.class);
        CustomerService service=ctx.getBean(CustomerService.class);
        System.out.println(service.findAll());
    }
}
.....................................................................................................
				How to simplify or modularize the bean creations
....................................................................................................

Modulariazation:
...............

Can we have multiple bean definition files- modular definition files

1.XML is so complex to maintain when app grows.
   -In general we can have multiple configurations
  like
	projectname-dao.xml
	cleartrip.dao.xml 
        cleartrip.service.xml
        cleartrip.entitis.xml
	cleartrip.beans.xml
via Program:
ConfigurableApplicationContext context = ClassPathXmlApplicationContext("bank-app.xml","account-repo.xml");

or
ConfigurableApplicationContext context = new ClassPathXmlApplicationContext
new String[] { "bank-app.xml", "account-repo.xml" });


How to break the configuration in annotations?

customer
 @Configuration
 class  CustomerConfig {
   ///customer beans
 }

order
@Configuration
 class  OrderConfig {
   ///customer beans
 }
accounts
@Configuration
 class  AccountsConfig {
   ///customer beans
 }


...
package com.valtech.spring.javaconfig;

//beans.xml === This java class

import com.valtech.spring.javaconfig.customer.CustomerConfig;
import com.valtech.spring.javaconfig.customer.OrderConfig;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import({CustomerConfig.class, OrderConfig.class})
public class AppConfig {
    //bean creation
//    @Bean
//    public CustomerService getCustomerService() {
//        return new CustomerService();
//    }
//    @Bean
//    public OrderService getOrderService(){
//        return new OrderService();
//    }
//    @Bean
//    public OrderRepo getOrderRepo(){
//        return new OrderRepo();
//    }
}

package com.valtech.spring.javaconfig.customer;

import com.valtech.spring.javaconfig.CustomerService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CustomerConfig {
    @Bean
    public CustomerService getCustomerService() {
        return new CustomerService();
    }
}

package com.valtech.spring.javaconfig.customer;

import com.valtech.spring.javaconfig.OrderRepo;
import com.valtech.spring.javaconfig.OrderService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OrderConfig {

    @Bean
    public OrderService getOrderService() {
        return new OrderService();
    }

    @Bean
    public OrderRepo getOrderRepo() {
        return new OrderRepo();
    }
}
........................................................................................................
			How to remove bean creations from the Java config
.......................................................................................................
@Component-scan


package com.valtech.spring.javaconfig;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
public class AppConfigComponentScanner {
}

  ApplicationContext ctx=new AnnotationConfigApplicationContext(AppConfigComponentScanner.class);
        CustomerService service=ctx.getBean(CustomerService.class);
        System.out.println(service.findAll());

        OrderService orderService=ctx.getBean(OrderService.class);
        System.out.println(orderService.findAll());
........................................................................................................
					Profiles and Environements
........................................................................................................


What is Profile?
 
  Profile is concept through which you can segregate beans and features.

Types of Profiles:

1.dev -  Development
2.test - Testing
3.prod  -Production


I want some beans in dev,but i dont want the same bean in production.

How to tell spring to activate different profiles in differnt environments to bootstrap only the beans we need.

Way 1 : Setting Profile via annotation

This is available in dev
@Profile("dev")
public class DevDataSourceConfig {

}
This not availble in dev
@Profile("!dev")
public class DevDataSourceConfig {

} 

				
Way 2: Setting Profile via code					

@Environment env

env.setActiveProfile("dev")

Way 3: Via env variable

export spring_profiles_active=dev

Way 3: application.properties
spring.profiles.active = dev

Way 4: During app lanuch time

java -jar target/myapp.jar -Pprod
........................................................................................................

package com.valtech.spring.app.beans.profiles;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class ProfileMain {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        //set
        ctx.getEnvironment().setActiveProfiles("prod");
        ctx.register(DataSourceConfig.class);
        ctx.refresh();

    }
}

package com.valtech.spring.app.beans.profiles;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

import javax.xml.transform.Source;

@Configuration
public class DataSourceConfig {

    @Bean
    @Profile("dev")
    public DevDataSource createDevDataSource(){
        return new DevDataSource();
    }
    @Bean
    @Profile("prod")
    public ProdDataSource createProdDataSource(){
        return new ProdDataSource();
    }
}


package com.valtech.spring.app.beans.profiles;

import org.springframework.stereotype.Component;

@Component
public class DevDataSource {
    public DevDataSource() {
        System.out.println("Dev Data Source");
    }

    public String getDevDataSource(){
        return "Dev Data Source";
    }

}

package com.valtech.spring.app.beans.profiles;

import org.springframework.stereotype.Component;

@Component
public class ProdDataSource {

    public ProdDataSource() {
        System.out.println("Production datasource");
    }

    public String getProdDataSource() {
        return "production data source";
    }
}
........................................................................................................
					@Enable Annotation
					  EnableXXX
.......................................................................................................

Enable annotation helps to inject not only bean or configuration but beyond that -  Cross Cutting Concerns

Cross Cutting Concerns:

Every Application requires some features

-Transaction
-Security
-concurrency
-caching
-AutoConfiguration
-ConfigServer
etc......
........................................................................................................
					Auto Configuration
				 Getting Spring Boot Architecture
.......................................................................................................

What is Spring Boot?

Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".

We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.

Spring Boot Focus Mainly Configuration

1.Build Configuration
2.Application Configuration.


Use case : i want to create WebApp using Spring- SpringMVC

Architecture:

WEB  +DATABASE CONNECTion using Mysql

Steps:

1.you have to create maven project

2.you need to add spring dependencies
   Spring-context
   Spring-web
   Spring-mvc
   mysql-connector-java
   commons-dbcp
   spring-orm
   hibernate-entitymanager
   jsr-250-api
 etc.........

3.App configuration
  src
   -main
      webapp
       -web-inf
       views
4.beans.xml / java config
   config
      WebListener COnfiguration
       -Change Spring container from plain to web
      WebAppConfig
        ViewResolver
  DataSourceConfig
  JPAConfig

........................................................................................................
					Why Spring Boot?

Spring Boot 
   starters reduces build dependency
   AutoConfigrator reduces the AppDepedency
  
1.Create stand-alone Spring applications
   You can deploy apps in containers,cloud.....easily

2.Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)
   SPring boots provides execuatble jar / fat jar /uber jar.	

3.Provide opinionated 'starter' dependencies to simplify your build configuration
     Looks like profie based configuration which is applied even for pom dependencies

4.Automatically configure Spring and 3rd party libraries whenever possible
    Via autoconfiguration and class path scanning.

Provide production-ready features such as metrics, health checks, and externalized configuration

Absolutely no code generation and no requirement for XML configuration
.......................................................................................................
How to start with Spring Boot Project?


spring-boot-starter:

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>

Spring Boot download all its dependencies based on root entry(starters)

Spring boot offers lot of maven plugins

mvn dependency:tree
mvn dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------< com.valtech:bootapp >-------------------------
[INFO] Building bootapp 0.0.1-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ bootapp ---
[INFO] com.valtech:bootapp:jar:0.0.1-SNAPSHOT
[INFO] +- org.springframework.boot:spring-boot-starter:jar:2.5.3:compile
[INFO] |  +- org.springframework.boot:spring-boot:jar:2.5.3:compile
[INFO] |  |  \- org.springframework:spring-context:jar:5.3.9:compile
[INFO] |  |     +- org.springframework:spring-aop:jar:5.3.9:compile
[INFO] |  |     +- org.springframework:spring-beans:jar:5.3.9:compile
[INFO] |  |     \- org.springframework:spring-expression:jar:5.3.9:compile
[INFO] |  +- org.springframework.boot:spring-boot-autoconfigure:jar:2.5.3:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.5.3:compile
[INFO] |  |  +- ch.qos.logback:logback-classic:jar:1.2.4:compile
[INFO] |  |  |  \- ch.qos.logback:logback-core:jar:1.2.4:compile
[INFO] |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.14.1:compile
[INFO] |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.14.1:compile
[INFO] |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.32:compile
[INFO] |  +- jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile
[INFO] |  +- org.springframework:spring-core:jar:5.3.9:compile
[INFO] |  |  \- org.springframework:spring-jcl:jar:5.3.9:compile
[INFO] |  \- org.yaml:snakeyaml:jar:1.28:compile
[INFO] \- org.springframework.boot:spring-boot-starter-test:jar:2.5.3:test
[INFO]    +- org.springframework.boot:spring-boot-test:jar:2.5.3:test
[INFO]    +- org.springframework.boot:spring-boot-test-autoconfigure:jar:2.5.3:test
[INFO]    +- com.jayway.jsonpath:json-path:jar:2.5.0:test
[INFO]    |  +- net.minidev:json-smart:jar:2.4.7:test
[INFO]    |  |  \- net.minidev:accessors-smart:jar:2.4.7:test
[INFO]    |  |     \- org.ow2.asm:asm:jar:9.1:test
[INFO]    |  \- org.slf4j:slf4j-api:jar:1.7.32:compile
[INFO]    +- jakarta.xml.bind:jakarta.xml.bind-api:jar:2.3.3:test
[INFO]    |  \- jakarta.activation:jakarta.activation-api:jar:1.2.2:test
[INFO]    +- org.assertj:assertj-core:jar:3.19.0:test
[INFO]    +- org.hamcrest:hamcrest:jar:2.2:test
[INFO]    +- org.junit.jupiter:junit-jupiter:jar:5.7.2:test
[INFO]    |  +- org.junit.jupiter:junit-jupiter-api:jar:5.7.2:test
[INFO]    |  |  +- org.apiguardian:apiguardian-api:jar:1.1.0:test
[INFO]    |  |  +- org.opentest4j:opentest4j:jar:1.2.0:test
[INFO]    |  |  \- org.junit.platform:junit-platform-commons:jar:1.7.2:test
[INFO]    |  +- org.junit.jupiter:junit-jupiter-params:jar:5.7.2:test
[INFO]    |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.7.2:test
[INFO]    |     \- org.junit.platform:junit-platform-engine:jar:1.7.2:test
[INFO]    +- org.mockito:mockito-core:jar:3.9.0:test
[INFO]    |  +- net.bytebuddy:byte-buddy:jar:1.10.22:test
[INFO]    |  +- net.bytebuddy:byte-buddy-agent:jar:1.10.22:test
[INFO]    |  \- org.objenesis:objenesis:jar:3.2:test
[INFO]    +- org.mockito:mockito-junit-jupiter:jar:3.9.0:test
[INFO]    +- org.skyscreamer:jsonassert:jar:1.5.0:test
[INFO]    |  \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test
[INFO]    +- org.springframework:spring-test:jar:5.3.9:test
[INFO]    \- org.xmlunit:xmlunit-core:jar:2.8.2:test
.......................................................................................................

2.Application Configuration
   
AutoConfiguration:
..................

Configuration is based on config meta data provied in "META-INF/spring.factories"

org.springframework.boot.spring-autoconfigure.2.5.3

spring.factories 
  It is meta configuration file read by spring container to create objects/beans based on certain conditions -rules


Spring container scans spring.factories file , starts loading configuration, which apples @condtional 
annotations.

  Container------|AppConfig----|spring.factories----starts initalizing beans/configurations/components   based on rules(conditions) => Spring Boot.


spring-configuration-meta.json

 This file contains default "Properties and values" - application.properties file default value
 eg
 {
      "name": "spring.redis",
      "type": "org.springframework.boot.autoconfigure.data.redis.RedisProperties",
      "sourceType": "org.springframework.boot.autoconfigure.data.redis.RedisProperties"
    },
    {
      "name": "spring.redis.cluster",
      "type": "org.springframework.boot.autoconfigure.data.redis.RedisProperties$Cluster",
      "sourceType": "org.springframework.boot.autoconfigure.data.redis.RedisProperties",
      "sourceMethod": "getCluster()"
    },
  
This file is loaded during boot process

additional-spring-configuration-metadata.json

  {
      "name": "server.port",
      "defaultValue": 8080
    }

Annotations are processed by ASM - java bytecode engineering lib.
https://asm.ow2.io/
........................................................................................................
					Conditional Bean Creations
........................................................................................................

When building a spring boot app, we sometimes want to only load beans or modules(configurations) into the application context(container) if some conditions met, Be it disable some beans during tests, or react to a certain property in the runtime env.

Spring has annotation Called @Conditional annotation.

This annotation allows us custom conditions to apply to parts of application context.

Why Conditional Beans?

 A spring application context contains an object graph that makes up all the beans that our application needs at runtime.
@Conditional annotation allows us to define conditions under which a certain bean is included into that object graph.

eg:

 Some beans work in test env, the same bean i dont want in production env.
 enable or disable some certain cross cutting concerns.
  eg:
    we have built a module that configures security, during dev test, we dont want to have username and passwords every time. so i want to disable the whole security module in local tests.
 
 if some external resources is available without which they cant work. 
   for eg: my application should not work if there is no logback.xml file has been found on classpath.


- if beans does not exits  / exits
- if module does not exits / exits
- if external does not exitis / exits


Declaring Conditional Bean:
..........................
In application, you can declare bean any where, optionaly we can add condition.

only if this condition is satisifed will the bean added to the application context

eg:

@Configuration
class MyBeanConfig {

 @Conditional(...)
 @Bean
 public MyBean  getBean(){ 
       return new MyBean()
 }

}


Module Level

@Configuration
@Conditional(...)
class MyBeanConfig {

 @Bean
 public MyBean  getBean(){ 
       return new MyBean()
 }

}

Component Level


@Component
@Conditional(...)
class MyComponent {

 
}
........................................................................................................

PreDefined Conditions:
......................
1.ConditionalOnProperty 
   Loads beans based on env property - application.properties
2.ConditionalOnExpression
3.ConditionalOnBean
4.ConditionalOnMissingBean
5.ConditionalOnResource
6.ConditionalOnClass
...
ConditionalOnJava -  version based

custom conditions

Boolean Operators

Or
And
...................................................................................................
					@SpringBootApplication
....................................................................................................


@@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
@SpringBootApplication


@Configuration   ------> Bean Creations - <bean>
@@SpringBootConfiguration

@EnableAutoConfiguration

 -Tells Spring boot to guess how you  want to configure spring,based on the jar dependencies that you have addeded
-IT auto configures the beans that are present in the class path.

 This simplifies the developer work by guuessing the required beans from the class path and configures to run the application.

-for eg, H2 is on your class path, you have not manually configured any database connection beans, then spring will auto configure an in memory database.


@ComponentScan
 Tells spring to look for other components,configurations and all services in the specificied package.
Spring is able to auto scan,detect  and register your beans or components from predefined project package.
if no package is specified current class package is taken as the root package.
.......................................................................................................

Spring Boot App bootstrap from java main method


SpringApplication.run(BootappApplication.class, args);

When you run this.

You will get

1.It creates ApplicationContext object -Spring Container

2.Register CommandLinePropertyResource

3.Refersh ApplicationContext

4.Trigger any CommandLineRunner Bean
........................................................................................................

Spring boot Application type:

1.Spring Pojo Style App -command Line - Core Spring App

2.Web Application - Servlet Based - Tomcat

3.Reactive Web Apps - Reactive Extensions-Project Reactor- Netty


Which application is default App?

Based on starter Dependency.
spring-boot-starter   ---- Spring Pojo Style app

















				


